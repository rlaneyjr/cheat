# To find files by case-insensitive extension (ex: .jpg, .JPG, .jpG):
find . -iname "*.jpg"

# To find directories:
find . -type d

# To find files:
find . -type f

# To find files by octal permission:
find . -type f -perm 777

# To find files with setuid bit set:
find . -xdev \( -perm -4000 \) -type f -print0 | xargs -0 ls -l

#Â To find files with extension '.txt' and remove them:
find ./path/ -name '*.txt' -exec rm '{}' \;

# To find files with extension '.txt' and look for a string into them:
find ./path/ -name '*.txt' | xargs grep 'string'

# To find files with size bigger than 5 Mebibyte and sort them by size:
find . -size +5M -type f -print0 | xargs -0 ls -Ssh | sort -z

# To find files bigger than 2 Megabyte and list them:
find . -type f -size +200000000c -exec ls -lh {} \; | awk '{ print $9 ": " $5 }'

# To find files modified more than 7 days ago and list file information
find . -type f -mtime +7d -ls

# To find symlinks owned by a user and list file information
find . -type l --user=username -ls

# To search for and delete empty directories
find . -type d -empty -exec rmdir {} \;

# To search for directories named build at a max depth of 2 directories
find . -maxdepth 2 -name build -type d

# To search all files who are not in .git directory
find . ! -iwholename '*.git*' -type f

# To find all files that have the same node (hard link) as MY_FILE_HERE
find . -type f -samefile MY_FILE_HERE 2>/dev/null

# To find all files in the current directory and modify their permissions
find . -type f -exec chmod 644 {} \;

# Examples from BSD manpage:
# Print out a list of all the files whose names do not end in .c.
find / \! -name "*.c" -print

# Print out a list of all the files owned by user ``wnj'' that are newer than the file ttt.
find / -newer ttt -user wnj -print

# Print out a list of all the files which are not both newer than ttt and owned by ``wnj''.
find / \! \( -newer ttt -user wnj \) -print

# Print out a list of all the files that are either owned by ``wnj'' or that are newer than ttt.
find / \( -newer ttt -or -user wnj \) -print

# Print out a list of all the files whose inode change time is more recent than the current time minus one minute.
find / -newerct '1 minute ago' -print

# Use the echo(1) command to print out a list of all the files.
find / -type f -exec echo {} \;

# Delete all broken symbolic links in /usr/ports/packages.
find -L /usr/ports/packages -type l -exec rm -- {} +

# Find files and directories that are at least seven levels deep in the working directory /usr/src.
find /usr/src -name CVS -prune -o -depth +6 -print

# Is not equivalent to the previous example, since -prune is not evaluated below level seven.
find /usr/src -name CVS -prune -o -mindepth 7 -print

# Examples from MACOS manpage:
# Find files named core in or below the directory /tmp and delete them.  Note that this will work incorrectly if there are any filenames containing newlines, single or double quotes, or spaces.
find /tmp -name core -type f -print | xargs /bin/rm -f

# Find files named core in or below the directory /tmp and delete them, processing filenames in such a way that file or directory names containing single or double quotes, spaces or newlines are correctly han-
# dled.  The -name test comes before the -type test in order to avoid having to call stat(2) on every file.
find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f

# Runs `file' on every file in or below the current directory.  Notice that the braces are enclosed in single quote marks to protect them from interpretation as shell script punctuation.  The semicolon is sim-
# ilarly protected by the use of a backslash, though single quotes could have been used in that case also.
find . -type f -exec file '{}' \;

# Traverse the filesystem just once, listing setuid files and directories into /root/suid.txt and large files into /root/big.txt.
find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \
\( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)

# Search for files in your home directory which have been modified in the last twenty-four hours.  This command works this way because the time since each file was last modified is divided by 24 hours and  any
# remainder is discarded.  That means that to match -mtime 0, a file will have to have a modification in the past which is less than 24 hours ago.
find $HOME -mtime 0

# Search for files which are executable but not readable.
find /sbin /usr/sbin -executable \! -readable -print

# Search  for  files  which have read and write permission for their owner, and group, but which other users can read but not write to.  Files which meet these criteria but have other permissions bits set (for
# example if someone can execute the file) will not be matched.
find . -perm 664

# Search for files which have read and write permission for their owner and group, and which other users can read, without regard to the presence of any extra permission bits (for example the executable  bit).
# This will match a file which has mode 0777, for example.
find . -perm -664

# Search for files which are writable by somebody (their owner, or their group, or anybody else).
find . -perm /222

# All  three  of  these  commands  do  the  same thing, but the first one uses the octal representation of the file mode, and the other two use the symbolic form.  These commands all search for files which are
# writable by either their owner or their group.  The files don't have to be writable by both the owner and group to be matched; either will do.
find . -perm /220
find . -perm /u+w,g+w
find . -perm /u=w,g=w

# Both these commands do the same thing; search for files which are writable by both their owner and their group.
find . -perm -220
find . -perm -g+w,u+w

# These two commands both search for files that are readable for everybody ( -perm -444 or -perm -a+r), have at least one write bit set ( -perm /222 or -perm /a+w) but are not executable for anybody ( !  -perm
# /111 and ! -perm /a+x respectively).
find . -perm -444 -perm /222 ! -perm /111
find . -perm -a+r -perm /a+w ! -perm /a+x

# This  command  copies the contents of /source-dir to /dest-dir, but omits files and directories named .snapshot (and anything in them).  It also omits files or directories whose name ends in ~, but not their
# contents.  The construct -prune -o \( ... -print0 \) is quite common.  The idea here is that the expression before -prune matches things which are to be pruned.  However, the  -prune  action  itself  returns
# true,  so the following -o ensures that the right hand side is evaluated only for those directories which didn't get pruned (the contents of the pruned directories are not even visited, so their contents are
# irrelevant).  The expression on the right hand side of the -o is in parentheses only for clarity.  It emphasises that the -print0 action takes place only for things that didn't have -prune applied  to  them.
# Because the default `and' condition between tests binds more tightly than -o, this is the default anyway, but the parentheses help to show what is going on.
cd /source-dir
find . -name .snapshot -prune -o \( \! -name *~ -print0 \)|
cpio -pmd0 /dest-dir

# Given the following directory of projects and their associated SCM administrative directories, perform an efficient search for the projects' roots:
find repo/ -exec test -d {}/.svn \; -or \
-exec test -d {}/.git \; -or -exec test -d {}/CVS \; \
-print -prune

# In this example, -prune prevents unnecessary descent into directories that have already been discovered (for example we do not search project3/src because we already found project3/.svn), but ensures sibling
# directories (project2 and project3) are found.
repo/project1/CVS
repo/gnu/project2/.svn
repo/gnu/project3/.svn
repo/gnu/project3/src/.svn
repo/project4/.git
